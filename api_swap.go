/*
AVNU API

REST API documentation for accessing liquidity on Layer 2.  AVNU is a decentralized exchange protocol enabling the fastest and the most efficient operations in DeFi for Layer 2 with better pricing, zero slippage, MEV-protection and gasless trading.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// SwapAPIService SwapAPI service
type SwapAPIService service

type ApiBuildRequest struct {
	ctx context.Context
	ApiService *SwapAPIService
	buildSwapRequestDtoV2 *BuildSwapRequestDtoV2
	askSignature *string
}

func (r ApiBuildRequest) BuildSwapRequestDtoV2(buildSwapRequestDtoV2 BuildSwapRequestDtoV2) ApiBuildRequest {
	r.buildSwapRequestDtoV2 = &buildSwapRequestDtoV2
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiBuildRequest) AskSignature(askSignature string) ApiBuildRequest {
	r.askSignature = &askSignature
	return r
}

func (r ApiBuildRequest) Execute() (*BuildSwapResponse, *http.Response, error) {
	return r.ApiService.BuildExecute(r)
}

/*
Build Build swap calldata

The build endpoint enables traders to construct swap calldata, which can be used to execute the transaction independently. Prior to targeting the build endpoint, traders should have already chosen a quote from the GET /quotes endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBuildRequest
*/
func (a *SwapAPIService) Build(ctx context.Context) ApiBuildRequest {
	return ApiBuildRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BuildSwapResponse
func (a *SwapAPIService) BuildExecute(r ApiBuildRequest) (*BuildSwapResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BuildSwapResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.Build")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v2/build"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.buildSwapRequestDtoV2 == nil {
		return localVarReturnValue, nil, reportError("buildSwapRequestDtoV2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	// body params
	localVarPostBody = r.buildSwapRequestDtoV2
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBuild1Request struct {
	ctx context.Context
	ApiService *SwapAPIService
	buildSwapRequest *BuildSwapRequest
	askSignature *string
}

func (r ApiBuild1Request) BuildSwapRequest(buildSwapRequest BuildSwapRequest) ApiBuild1Request {
	r.buildSwapRequest = &buildSwapRequest
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiBuild1Request) AskSignature(askSignature string) ApiBuild1Request {
	r.askSignature = &askSignature
	return r
}

func (r ApiBuild1Request) Execute() (*BuildSwapResponse, *http.Response, error) {
	return r.ApiService.Build1Execute(r)
}

/*
Build1 Build swap calldata

The build endpoint enables traders to construct swap calldata, which can be used to execute the transaction independently. Prior to targeting the build endpoint, traders should have already chosen a quote from the GET /quotes endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBuild1Request
*/
func (a *SwapAPIService) Build1(ctx context.Context) ApiBuild1Request {
	return ApiBuild1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BuildSwapResponse
func (a *SwapAPIService) Build1Execute(r ApiBuild1Request) (*BuildSwapResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BuildSwapResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.Build1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v1/build"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.buildSwapRequest == nil {
		return localVarReturnValue, nil, reportError("buildSwapRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	// body params
	localVarPostBody = r.buildSwapRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBuildTypedData2Request struct {
	ctx context.Context
	ApiService *SwapAPIService
	buildSwapTypedDataRequest *BuildSwapTypedDataRequest
	askSignature *string
}

func (r ApiBuildTypedData2Request) BuildSwapTypedDataRequest(buildSwapTypedDataRequest BuildSwapTypedDataRequest) ApiBuildTypedData2Request {
	r.buildSwapTypedDataRequest = &buildSwapTypedDataRequest
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiBuildTypedData2Request) AskSignature(askSignature string) ApiBuildTypedData2Request {
	r.askSignature = &askSignature
	return r
}

func (r ApiBuildTypedData2Request) Execute() (*TypedData, *http.Response, error) {
	return r.ApiService.BuildTypedData2Execute(r)
}

/*
BuildTypedData2 Method for BuildTypedData2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBuildTypedData2Request
*/
func (a *SwapAPIService) BuildTypedData2(ctx context.Context) ApiBuildTypedData2Request {
	return ApiBuildTypedData2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TypedData
func (a *SwapAPIService) BuildTypedData2Execute(r ApiBuildTypedData2Request) (*TypedData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TypedData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.BuildTypedData2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v2/build-typed-data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.buildSwapTypedDataRequest == nil {
		return localVarReturnValue, nil, reportError("buildSwapTypedDataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	// body params
	localVarPostBody = r.buildSwapTypedDataRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExecute2Request struct {
	ctx context.Context
	ApiService *SwapAPIService
	executeSwapRequest *ExecuteSwapRequest
	askSignature *string
}

func (r ApiExecute2Request) ExecuteSwapRequest(executeSwapRequest ExecuteSwapRequest) ApiExecute2Request {
	r.executeSwapRequest = &executeSwapRequest
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiExecute2Request) AskSignature(askSignature string) ApiExecute2Request {
	r.askSignature = &askSignature
	return r
}

func (r ApiExecute2Request) Execute() (*ExecuteSwapResponse, *http.Response, error) {
	return r.ApiService.Execute2Execute(r)
}

/*
Execute2 Execute swap

This endpoint allows trader to execute swap transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExecute2Request
*/
func (a *SwapAPIService) Execute2(ctx context.Context) ApiExecute2Request {
	return ApiExecute2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExecuteSwapResponse
func (a *SwapAPIService) Execute2Execute(r ApiExecute2Request) (*ExecuteSwapResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExecuteSwapResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.Execute2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v2/execute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.executeSwapRequest == nil {
		return localVarReturnValue, nil, reportError("executeSwapRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	// body params
	localVarPostBody = r.executeSwapRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPricesRequest struct {
	ctx context.Context
	ApiService *SwapAPIService
	sellTokenAddress *string
	buyTokenAddress *string
	sellAmount *string
	askSignature *string
}

// The token address user wants to sell
func (r ApiGetPricesRequest) SellTokenAddress(sellTokenAddress string) ApiGetPricesRequest {
	r.sellTokenAddress = &sellTokenAddress
	return r
}

// The token address user wants to buy
func (r ApiGetPricesRequest) BuyTokenAddress(buyTokenAddress string) ApiGetPricesRequest {
	r.buyTokenAddress = &buyTokenAddress
	return r
}

// The Amount of token user wants to sell
func (r ApiGetPricesRequest) SellAmount(sellAmount string) ApiGetPricesRequest {
	r.sellAmount = &sellAmount
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiGetPricesRequest) AskSignature(askSignature string) ApiGetPricesRequest {
	r.askSignature = &askSignature
	return r
}

func (r ApiGetPricesRequest) Execute() (*Quote, *http.Response, error) {
	return r.ApiService.GetPricesExecute(r)
}

/*
GetPrices Find the prices of DEX applications

This endpoint returns the prices of AMM without any path optimization. It allows to measure the performance of the results from the getQuotes endpoints. The prices will be returned and are sorted (best first).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPricesRequest
*/
func (a *SwapAPIService) GetPrices(ctx context.Context) ApiGetPricesRequest {
	return ApiGetPricesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Quote
func (a *SwapAPIService) GetPricesExecute(r ApiGetPricesRequest) (*Quote, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Quote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.GetPrices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v2/prices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sellTokenAddress == nil {
		return localVarReturnValue, nil, reportError("sellTokenAddress is required and must be specified")
	}
	if r.buyTokenAddress == nil {
		return localVarReturnValue, nil, reportError("buyTokenAddress is required and must be specified")
	}
	if r.sellAmount == nil {
		return localVarReturnValue, nil, reportError("sellAmount is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sellTokenAddress", r.sellTokenAddress, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "buyTokenAddress", r.buyTokenAddress, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "sellAmount", r.sellAmount, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPrices1Request struct {
	ctx context.Context
	ApiService *SwapAPIService
	sellTokenAddress *string
	buyTokenAddress *string
	sellAmount *string
	askSignature *string
}

// The token address user wants to sell
func (r ApiGetPrices1Request) SellTokenAddress(sellTokenAddress string) ApiGetPrices1Request {
	r.sellTokenAddress = &sellTokenAddress
	return r
}

// The token address user wants to buy
func (r ApiGetPrices1Request) BuyTokenAddress(buyTokenAddress string) ApiGetPrices1Request {
	r.buyTokenAddress = &buyTokenAddress
	return r
}

// The Amount of token user wants to sell
func (r ApiGetPrices1Request) SellAmount(sellAmount string) ApiGetPrices1Request {
	r.sellAmount = &sellAmount
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiGetPrices1Request) AskSignature(askSignature string) ApiGetPrices1Request {
	r.askSignature = &askSignature
	return r
}

func (r ApiGetPrices1Request) Execute() (*Quote, *http.Response, error) {
	return r.ApiService.GetPrices1Execute(r)
}

/*
GetPrices1 Find the prices of DEX applications

This endpoint returns the prices of AMM without any path optimization. It allows to measure the performance of the results from the getQuotes endpoints. The prices will be returned and are sorted (best first).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPrices1Request
*/
func (a *SwapAPIService) GetPrices1(ctx context.Context) ApiGetPrices1Request {
	return ApiGetPrices1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Quote
func (a *SwapAPIService) GetPrices1Execute(r ApiGetPrices1Request) (*Quote, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Quote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.GetPrices1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v1/prices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sellTokenAddress == nil {
		return localVarReturnValue, nil, reportError("sellTokenAddress is required and must be specified")
	}
	if r.buyTokenAddress == nil {
		return localVarReturnValue, nil, reportError("buyTokenAddress is required and must be specified")
	}
	if r.sellAmount == nil {
		return localVarReturnValue, nil, reportError("sellAmount is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sellTokenAddress", r.sellTokenAddress, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "buyTokenAddress", r.buyTokenAddress, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "sellAmount", r.sellAmount, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuotesRequest struct {
	ctx context.Context
	ApiService *SwapAPIService
	sellTokenAddress *string
	buyTokenAddress *string
	sellAmount *string
	buyAmount *string
	takerAddress *string
	excludeSources *[]string
	size *int64
	integratorFees *string
	integratorFeeRecipient *string
	integratorName *string
	origin *string
	userAgent *string
	xFORWARDEDFOR *string
	askSignature *string
}

// The token address user wants to sell
func (r ApiGetQuotesRequest) SellTokenAddress(sellTokenAddress string) ApiGetQuotesRequest {
	r.sellTokenAddress = &sellTokenAddress
	return r
}

// The token address user wants to buy
func (r ApiGetQuotesRequest) BuyTokenAddress(buyTokenAddress string) ApiGetQuotesRequest {
	r.buyTokenAddress = &buyTokenAddress
	return r
}

// The amount of token user wants to sell. It must be defined if buyAmount is not defined.
func (r ApiGetQuotesRequest) SellAmount(sellAmount string) ApiGetQuotesRequest {
	r.sellAmount = &sellAmount
	return r
}

// The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.
func (r ApiGetQuotesRequest) BuyAmount(buyAmount string) ApiGetQuotesRequest {
	r.buyAmount = &buyAmount
	return r
}

// The address which will fill the quote
func (r ApiGetQuotesRequest) TakerAddress(takerAddress string) ApiGetQuotesRequest {
	r.takerAddress = &takerAddress
	return r
}

// The sources that the user wants to exclude
func (r ApiGetQuotesRequest) ExcludeSources(excludeSources []string) ApiGetQuotesRequest {
	r.excludeSources = &excludeSources
	return r
}

// The maximum number of returned quotes
func (r ApiGetQuotesRequest) Size(size int64) ApiGetQuotesRequest {
	r.size = &size
	return r
}

// Fee amount in bps, 30 is 0.3%
func (r ApiGetQuotesRequest) IntegratorFees(integratorFees string) ApiGetQuotesRequest {
	r.integratorFees = &integratorFees
	return r
}

// Required when &#x60;integratorFees&#x60; is defined. You need to provide the address of your fee collector.
func (r ApiGetQuotesRequest) IntegratorFeeRecipient(integratorFeeRecipient string) ApiGetQuotesRequest {
	r.integratorFeeRecipient = &integratorFeeRecipient
	return r
}

// The name of your application
func (r ApiGetQuotesRequest) IntegratorName(integratorName string) ApiGetQuotesRequest {
	r.integratorName = &integratorName
	return r
}

func (r ApiGetQuotesRequest) Origin(origin string) ApiGetQuotesRequest {
	r.origin = &origin
	return r
}

func (r ApiGetQuotesRequest) UserAgent(userAgent string) ApiGetQuotesRequest {
	r.userAgent = &userAgent
	return r
}

func (r ApiGetQuotesRequest) XFORWARDEDFOR(xFORWARDEDFOR string) ApiGetQuotesRequest {
	r.xFORWARDEDFOR = &xFORWARDEDFOR
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiGetQuotesRequest) AskSignature(askSignature string) ApiGetQuotesRequest {
	r.askSignature = &askSignature
	return r
}

func (r ApiGetQuotesRequest) Execute() (*Quote, *http.Response, error) {
	return r.ApiService.GetQuotesExecute(r)
}

/*
GetQuotes Find the best quotes

This endpoint permits you to receive the best quotes for performing a swap. The endpoint provides default quotes that are sorted in descending order (best first). Each quote is assigned a unique quoteId, which you will use when making calls to the /swap/v2/build or /swap/v2/execute endpoints to initiate the actual swap process.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQuotesRequest
*/
func (a *SwapAPIService) GetQuotes(ctx context.Context) ApiGetQuotesRequest {
	return ApiGetQuotesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Quote
func (a *SwapAPIService) GetQuotesExecute(r ApiGetQuotesRequest) (*Quote, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Quote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.GetQuotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v2/quotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sellTokenAddress == nil {
		return localVarReturnValue, nil, reportError("sellTokenAddress is required and must be specified")
	}
	if r.buyTokenAddress == nil {
		return localVarReturnValue, nil, reportError("buyTokenAddress is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sellTokenAddress", r.sellTokenAddress, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "buyTokenAddress", r.buyTokenAddress, "")
	if r.sellAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellAmount", r.sellAmount, "")
	}
	if r.buyAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buyAmount", r.buyAmount, "")
	}
	if r.takerAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "takerAddress", r.takerAddress, "")
	}
	if r.excludeSources != nil {
		t := *r.excludeSources
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSources", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSources", t, "multi")
		}
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.integratorFees != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integratorFees", r.integratorFees, "")
	}
	if r.integratorFeeRecipient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integratorFeeRecipient", r.integratorFeeRecipient, "")
	}
	if r.integratorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integratorName", r.integratorName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.origin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Origin", r.origin, "")
	}
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.xFORWARDEDFOR != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-FORWARDED-FOR", r.xFORWARDEDFOR, "")
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQuotes1Request struct {
	ctx context.Context
	ApiService *SwapAPIService
	sellTokenAddress *string
	buyTokenAddress *string
	sellAmount *string
	buyAmount *string
	takerAddress *string
	excludeSources *[]string
	size *int64
	integratorFees *string
	integratorFeeRecipient *string
	integratorName *string
	origin *string
	userAgent *string
	xFORWARDEDFOR *string
	askSignature *string
}

// The token address user wants to sell
func (r ApiGetQuotes1Request) SellTokenAddress(sellTokenAddress string) ApiGetQuotes1Request {
	r.sellTokenAddress = &sellTokenAddress
	return r
}

// The token address user wants to buy
func (r ApiGetQuotes1Request) BuyTokenAddress(buyTokenAddress string) ApiGetQuotes1Request {
	r.buyTokenAddress = &buyTokenAddress
	return r
}

// The amount of token user wants to sell. It must be defined if buyAmount is not defined.
func (r ApiGetQuotes1Request) SellAmount(sellAmount string) ApiGetQuotes1Request {
	r.sellAmount = &sellAmount
	return r
}

// The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.
func (r ApiGetQuotes1Request) BuyAmount(buyAmount string) ApiGetQuotes1Request {
	r.buyAmount = &buyAmount
	return r
}

// The address which will fill the quote
func (r ApiGetQuotes1Request) TakerAddress(takerAddress string) ApiGetQuotes1Request {
	r.takerAddress = &takerAddress
	return r
}

// The sources that the user wants to exclude
func (r ApiGetQuotes1Request) ExcludeSources(excludeSources []string) ApiGetQuotes1Request {
	r.excludeSources = &excludeSources
	return r
}

// The maximum number of returned quotes
func (r ApiGetQuotes1Request) Size(size int64) ApiGetQuotes1Request {
	r.size = &size
	return r
}

// Fee amount in bps, 30 is 0.3%
func (r ApiGetQuotes1Request) IntegratorFees(integratorFees string) ApiGetQuotes1Request {
	r.integratorFees = &integratorFees
	return r
}

// Required when &#x60;integratorFees&#x60; is defined. You need to provide the address of your fee collector.
func (r ApiGetQuotes1Request) IntegratorFeeRecipient(integratorFeeRecipient string) ApiGetQuotes1Request {
	r.integratorFeeRecipient = &integratorFeeRecipient
	return r
}

// The name of your application
func (r ApiGetQuotes1Request) IntegratorName(integratorName string) ApiGetQuotes1Request {
	r.integratorName = &integratorName
	return r
}

func (r ApiGetQuotes1Request) Origin(origin string) ApiGetQuotes1Request {
	r.origin = &origin
	return r
}

func (r ApiGetQuotes1Request) UserAgent(userAgent string) ApiGetQuotes1Request {
	r.userAgent = &userAgent
	return r
}

func (r ApiGetQuotes1Request) XFORWARDEDFOR(xFORWARDEDFOR string) ApiGetQuotes1Request {
	r.xFORWARDEDFOR = &xFORWARDEDFOR
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiGetQuotes1Request) AskSignature(askSignature string) ApiGetQuotes1Request {
	r.askSignature = &askSignature
	return r
}

func (r ApiGetQuotes1Request) Execute() (*Quote, *http.Response, error) {
	return r.ApiService.GetQuotes1Execute(r)
}

/*
GetQuotes1 Find the best quotes

This endpoint permits you to receive the best quotes for performing a swap. The endpoint provides default quotes that are sorted in descending order (best first). Each quote is assigned a unique quoteId, which you will use when making calls to the /swap/v1/build or /swap/v1/execute endpoints to initiate the actual swap process.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQuotes1Request
*/
func (a *SwapAPIService) GetQuotes1(ctx context.Context) ApiGetQuotes1Request {
	return ApiGetQuotes1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Quote
func (a *SwapAPIService) GetQuotes1Execute(r ApiGetQuotes1Request) (*Quote, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Quote
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.GetQuotes1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v1/quotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sellTokenAddress == nil {
		return localVarReturnValue, nil, reportError("sellTokenAddress is required and must be specified")
	}
	if r.buyTokenAddress == nil {
		return localVarReturnValue, nil, reportError("buyTokenAddress is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sellTokenAddress", r.sellTokenAddress, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "buyTokenAddress", r.buyTokenAddress, "")
	if r.sellAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sellAmount", r.sellAmount, "")
	}
	if r.buyAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "buyAmount", r.buyAmount, "")
	}
	if r.takerAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "takerAddress", r.takerAddress, "")
	}
	if r.excludeSources != nil {
		t := *r.excludeSources
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSources", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeSources", t, "multi")
		}
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.integratorFees != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integratorFees", r.integratorFees, "")
	}
	if r.integratorFeeRecipient != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integratorFeeRecipient", r.integratorFeeRecipient, "")
	}
	if r.integratorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "integratorName", r.integratorName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.origin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Origin", r.origin, "")
	}
	if r.userAgent != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "User-Agent", r.userAgent, "")
	}
	if r.xFORWARDEDFOR != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-FORWARDED-FOR", r.xFORWARDEDFOR, "")
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSourcesRequest struct {
	ctx context.Context
	ApiService *SwapAPIService
	page *int32
	size *int32
	sort *[]string
	askSignature *string
}

// Zero-based page index (0..N)
func (r ApiGetSourcesRequest) Page(page int32) ApiGetSourcesRequest {
	r.page = &page
	return r
}

// The size of the page to be returned
func (r ApiGetSourcesRequest) Size(size int32) ApiGetSourcesRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetSourcesRequest) Sort(sort []string) ApiGetSourcesRequest {
	r.sort = &sort
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiGetSourcesRequest) AskSignature(askSignature string) ApiGetSourcesRequest {
	r.askSignature = &askSignature
	return r
}

func (r ApiGetSourcesRequest) Execute() (*ExecuteSwapResponse, *http.Response, error) {
	return r.ApiService.GetSourcesExecute(r)
}

/*
GetSources Fetch the list of supported sources

This endpoint allows to return the list of all supported sources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSourcesRequest
*/
func (a *SwapAPIService) GetSources(ctx context.Context) ApiGetSourcesRequest {
	return ApiGetSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExecuteSwapResponse
func (a *SwapAPIService) GetSourcesExecute(r ApiGetSourcesRequest) (*ExecuteSwapResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExecuteSwapResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.GetSources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v2/sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 20
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSources1Request struct {
	ctx context.Context
	ApiService *SwapAPIService
	page *int32
	size *int32
	sort *[]string
	askSignature *string
}

// Zero-based page index (0..N)
func (r ApiGetSources1Request) Page(page int32) ApiGetSources1Request {
	r.page = &page
	return r
}

// The size of the page to be returned
func (r ApiGetSources1Request) Size(size int32) ApiGetSources1Request {
	r.size = &size
	return r
}

// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetSources1Request) Sort(sort []string) ApiGetSources1Request {
	r.sort = &sort
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiGetSources1Request) AskSignature(askSignature string) ApiGetSources1Request {
	r.askSignature = &askSignature
	return r
}

func (r ApiGetSources1Request) Execute() (*ExecuteSwapResponse, *http.Response, error) {
	return r.ApiService.GetSources1Execute(r)
}

/*
GetSources1 Fetch the list of supported sources

This endpoint allows to return the list of all supported sources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSources1Request
*/
func (a *SwapAPIService) GetSources1(ctx context.Context) ApiGetSources1Request {
	return ApiGetSources1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExecuteSwapResponse
func (a *SwapAPIService) GetSources1Execute(r ApiGetSources1Request) (*ExecuteSwapResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExecuteSwapResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.GetSources1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v1/sources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 20
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokensRequest struct {
	ctx context.Context
	ApiService *SwapAPIService
	page *int32
	size *int32
	sort *[]string
	askSignature *string
}

// Zero-based page index (0..N)
func (r ApiGetTokensRequest) Page(page int32) ApiGetTokensRequest {
	r.page = &page
	return r
}

// The size of the page to be returned
func (r ApiGetTokensRequest) Size(size int32) ApiGetTokensRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetTokensRequest) Sort(sort []string) ApiGetTokensRequest {
	r.sort = &sort
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiGetTokensRequest) AskSignature(askSignature string) ApiGetTokensRequest {
	r.askSignature = &askSignature
	return r
}

func (r ApiGetTokensRequest) Execute() (*ExecuteSwapResponse, *http.Response, error) {
	return r.ApiService.GetTokensExecute(r)
}

/*
GetTokens Fetch supported tokens

This endpoint allows to fetch the list of all officially supported tokens

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokensRequest
*/
func (a *SwapAPIService) GetTokens(ctx context.Context) ApiGetTokensRequest {
	return ApiGetTokensRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExecuteSwapResponse
func (a *SwapAPIService) GetTokensExecute(r ApiGetTokensRequest) (*ExecuteSwapResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExecuteSwapResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.GetTokens")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v2/tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 20
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokens1Request struct {
	ctx context.Context
	ApiService *SwapAPIService
	page *int32
	size *int32
	sort *[]string
	askSignature *string
}

// Zero-based page index (0..N)
func (r ApiGetTokens1Request) Page(page int32) ApiGetTokens1Request {
	r.page = &page
	return r
}

// The size of the page to be returned
func (r ApiGetTokens1Request) Size(size int32) ApiGetTokens1Request {
	r.size = &size
	return r
}

// Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetTokens1Request) Sort(sort []string) ApiGetTokens1Request {
	r.sort = &sort
	return r
}

// When the given value is provided with the value &#39;true&#39;, the response header &#39;signature&#39; will be returned.
func (r ApiGetTokens1Request) AskSignature(askSignature string) ApiGetTokens1Request {
	r.askSignature = &askSignature
	return r
}

func (r ApiGetTokens1Request) Execute() (*ExecuteSwapResponse, *http.Response, error) {
	return r.ApiService.GetTokens1Execute(r)
}

/*
GetTokens1 Fetch supported tokens

This endpoint allows to fetch the list of all officially supported tokens

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokens1Request
*/
func (a *SwapAPIService) GetTokens1(ctx context.Context) ApiGetTokens1Request {
	return ApiGetTokens1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExecuteSwapResponse
func (a *SwapAPIService) GetTokens1Execute(r ApiGetTokens1Request) (*ExecuteSwapResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExecuteSwapResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SwapAPIService.GetTokens1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/swap/v1/tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 20
		r.size = &defaultValue
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.askSignature != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ask-signature", r.askSignature, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
